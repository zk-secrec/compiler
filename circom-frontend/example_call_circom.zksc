// ./runrust circom-frontend/example_call_circom.zksc --circom -o circom/example

use CallCircom::*;

type N : Nat = 21888242871839275222246405745257275088548364400416034343698204186575808495617; // default modulus of circom

fn main() where Field[N] {
    // To call a circom circuit with name CIRCUIT (replace with the real name):
    // 1. Install the circom compiler if it is not yet installed.
    // 2. Add the files CIRCUIT.circom and CIRCUIT_prime.txt to the directory circom-frontend in the compiler repository.
    //    These files can be generated by the circom backend of the ZKSCC.
    //    If using a .circom file from another source then the _prime.txt file needs to be created,
    //    containing the name of the prime (bn128 or bls12381).
    // 3. Call
    //        ./prepare_circuit CIRCUIT
    //    in the circom-frontend directory, which creates the file CIRCUIT.r1cs (the R1CS circuit)
    //    and the directory CIRCUIT_cpp (the witness extender).
    // 4. Add
    //        use CallCircom::*;
    //    to the .zksc file from which the circom circuit needs to be called.
    // 5. Call the circuit using
    //        let out = call_circom("CIRCUIT", ins, wit);
    //    where
    //        ins : list[uint[N] $post @verifier] is the list of instance values for the circuit
    //        wit : list[uint[N] $post @prover] is the list of (unextended) witness values for the circuit
    //        out : list[uint[N] $post @prover] is the list of output values returned from the circuit

    // The following assumes the circuit "cube" has been added and prepared.
    // It can be added with the following command in the compiler directory:
    //     ./runrust circom/example_cube_circom.zksc --circom -o circom-frontend/cube --public
    // It can be prepared with the following in the circom-frontend directory:
    //     ./prepare_circuit cube
    let y : uint[N] $post @verifier = wire { 27 };
    let x : uint[N] $post @prover = wire { 3 };
    let _out = call_circom("cube", [y], [x]);

    let y : uint[N] $post @verifier = wire { 64 };
    let x : uint[N] $post @prover = wire { 4 };
    let _out = call_circom("cube", [y], [x]);

    // Constant inputs also work and are automatically added to wires
    let _out = call_circom("cube", [8 : uint[N] $post @verifier], [2]);
    let _out = call_circom("cube", [64], [x]);
    let _out = call_circom("cube", [y], [4]);

    // cube_out.circom returns the cube of the witness instead of checking that it is equal to the instance
    // It must be prepared with the following in the circom-frontend directory:
    //     ./prepare_circuit cube_out
    let y : uint[N] $post @verifier = wire { 125 };
    let x : uint[N] $post @prover = wire { 5 };
    let out = call_circom("cube_out", [], [x]);
    assert_zero(out[0] - y as @prover);
}
